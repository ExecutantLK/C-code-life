/*有一个矩阵map，它每个格子有一个权值。从左上角的格子开始每次只能向右或者向下走，最后到达右下角的位置，路径上所有的数字累加起来就是路径和，
返回所有的路径中最小的路径和。给定一个矩阵map及它的行数n和列数m，请返回最小路径和。保证行列数均小于等于100.
输入输出样例：
第一行，输入n,m表示这个矩阵的行数和列数，接下来的n行，输入每行的m个数字，也即每个格子的权值。最后输出最小路径和。如：
2 3
1 2 3 
1 1 1
输出：4*/


#include<stdio.h>  
#include<stdlib.h>  
int a[100][100];   //存数据的数组 
int dp[100][100];   //暂存路径和的数组，利用它的分解来 
  
int Min(int a,int b){  //计算最小路径和 
    if(a<b){  
        return a;  
    }else{  
        return b;  
    }  
}  
  
int getMin(int m,int n){  
    int min;  
      
    dp[0][0]=a[0][0];  
    for(int i=1;i<m;i++){  
        dp[i][0]=a[i][0]+dp[i-1][0];       //将每一个dp都填满，计算出来，届时直接使用 
    }  
    for(int i=1;i<n;i++){  
        dp[0][i]=a[0][i]+dp[0][i-1];  
    }  
      
    for(int i=1;i<m;i++){  
        for(int j=1;j<n;j++){  
            min=Min(dp[i-1][j],dp[i][j-1]);  //找出最小路径和 
            dp[i][j]=min+a[i][j];  //加上a才是最终答案 
        }  
    }  
      
    return dp[m-1][n-1];  //因为其实是数组，所以序号要小一位 
}  
  
int main(){  
    int m,n;  
    scanf("%d%d",&m,&n);  
      
    for(int i=0;i<m;i++){  
        for(int j=0;j<n;j++){  
            scanf("%d",&a[i][j]);  
        }  
    }  
          
    printf("%d\n",getMin(m,n));  
  
    return 0;  
}   
